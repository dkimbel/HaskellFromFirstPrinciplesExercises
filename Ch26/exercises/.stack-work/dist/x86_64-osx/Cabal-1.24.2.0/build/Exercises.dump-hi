
==================== FINAL INTERFACE ====================
2017-09-12 02:38:17.894971 UTC

interface exercises-0.1.0.0-4iJ1dNT2ZZSEw8yTgykqM4:Exercises 8002
  interface hash: b53204fc48d8b793e928013f264bd0fb
  ABI hash: d709eeedad508c77e0e66bb437dffed6
  export-list hash: 5566a7cc3c431b8099a586c1abef30c4
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 6fc74547fbd72660fbdc96d0ba10d9b2
  sig of: Nothing
  used TH splices: False
  where
exports:
  Exercises.rDec
  Exercises.rDec'
  Exercises.rPrintAndInc
  Exercises.rShow
  Exercises.rShow'
  Exercises.sPrintIncAccum
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 transformers-0.5.2.0@transformers-0.5.2.0
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Functor.Identity base-4.9.1.0:Data.List.NonEmpty
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Semigroup
                         base-4.9.1.0:Data.Type.Equality base-4.9.1.0:Data.Version
                         base-4.9.1.0:Data.Void base-4.9.1.0:GHC.Exts
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Functor.Identity 6ee67943d44d50091e12d22df04741f0
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.IO c9de64c5f5407c4cf1c52500c4d15200
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Reader 1b607a084a390ae0e50e8f8dcbf2541a
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 371607e50dde46b5f4103b3ab334a497
2341b4d2fd99078c6456a0af1a758613
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Exercises.$trModule2
                   Exercises.$trModule1) -}
d2d2de666cbd3fd0f2e56576926913bb
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Exercises"#) -}
edf6bcd5886f007a38a750a2800c67a1
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "exercises-0.1.0.0-4iJ1dNT2ZZSEw8yTgykqM4"#) -}
ddf37093e28d7f0f15d6002b0b7da891
  rDec :: GHC.Num.Num a => Control.Monad.Trans.Reader.Reader a a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,1*C1(U))>,
     Unfolding: (\ @ a ($dNum :: GHC.Num.Num a) ->
                 let {
                   lvl :: a = GHC.Num.fromInteger @ a $dNum Exercises.rDec1
                 } in
                 (\ (r :: a) -> GHC.Num.- @ a $dNum r lvl)
                   `cast`
                 (Trans
                      (<a>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R))
                      (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                <*>_N <a>_R <Data.Functor.Identity.Identity>_R <a>_N)))) -}
01e84f7ece1ece7cbdb24817cf8f7680
  rDec' :: GHC.Num.Num a => Control.Monad.Trans.Reader.Reader a a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(A,1*U,A,A,A,A,1*C1(U))>,
     Unfolding: (\ @ a ($dNum :: GHC.Num.Num a) ->
                 let {
                   f :: a -> a -> a = GHC.Num.- @ a $dNum
                 } in
                 let {
                   x :: a = GHC.Num.fromInteger @ a $dNum Exercises.rDec1
                 } in
                 (\ (x1 :: a) -> f x1 x)
                   `cast`
                 (Trans
                      (<a>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R))
                      (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                <*>_N <a>_R <Data.Functor.Identity.Identity>_R <a>_N)))) -}
7322ae230444b8006eaa3851ac89a9e3
  rDec1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
c6156017ce3d359305261e31cfdec7c1
  rPrintAndInc ::
    (GHC.Num.Num a, GHC.Show.Show a) =>
    Control.Monad.Trans.Reader.ReaderT a GHC.Types.IO a
  {- Arity: 2,
     Strictness: <L,U(C(C1(U)),A,A,A,A,A,1*C1(U))><L,U(A,C(U),A)>,
     Unfolding: (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   ($dShow :: GHC.Show.Show a) ->
                 let {
                   lvl :: a = GHC.Num.fromInteger @ a $dNum Exercises.rDec1
                 } in
                 (\ (r :: a) (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                  case GHC.IO.Handle.Text.hPutStr2
                         GHC.IO.Handle.FD.stdout
                         (GHC.CString.unpackAppendCString#
                            "Hi: "#
                            (GHC.Show.show @ a $dShow r))
                         GHC.Types.True
                         s of ds1 { (#,#) ipv ipv1 ->
                  (# ipv, GHC.Num.+ @ a $dNum r lvl #) })
                   `cast`
                 (Trans
                      (<a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R))
                      (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                <*>_N <a>_R <GHC.Types.IO>_R <a>_N)))) -}
d29cdb7a363795d26047fed2060e0274
  rShow ::
    GHC.Show.Show a =>
    Control.Monad.Trans.Reader.ReaderT
      a Data.Functor.Identity.Identity GHC.Base.String
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(S)L),1*U(A,1*C1(U),A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Exercises.rShow1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Show.Show a>_R
                 ->_R Trans
                          (<a>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0] <GHC.Base.String>_R))
                          (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                    <*>_N
                                    <a>_R
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Base.String>_N))) -}
0342ac08ff707ce138ecf2c6316e00af
  rShow' ::
    GHC.Show.Show a =>
    Control.Monad.Trans.Reader.ReaderT
      a Data.Functor.Identity.Identity GHC.Base.String
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(S)L),1*U(A,1*C1(U),A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Exercises.rShow1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Show.Show a>_R
                 ->_R Trans
                          (<a>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0] <GHC.Base.String>_R))
                          (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                    <*>_N
                                    <a>_R
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Base.String>_N))) -}
ca2ba9ef371835b4a391487b9400611f
  rShow1 :: GHC.Show.Show a => a -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(S)L),1*U(A,1*C1(U),A)><L,U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a ($dShow :: GHC.Show.Show a) (r :: a) ->
                 GHC.Show.show @ a $dShow r) -}
43be38fe2ee1140da2584782002406bc
  sPrintIncAccum ::
    (GHC.Num.Num a, GHC.Show.Show a) =>
    Control.Monad.Trans.State.Lazy.StateT
      a GHC.Types.IO GHC.Base.String
  {- Arity: 2,
     Strictness: <L,U(C(C1(U)),A,A,A,A,A,1*C1(U))><L,U(A,C(U),A)>,
     Unfolding: (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   ($dShow :: GHC.Show.Show a) ->
                 let {
                   lvl :: a = GHC.Num.fromInteger @ a $dNum Exercises.rDec1
                 } in
                 (\ (s :: a) (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                  case GHC.IO.Handle.Text.hPutStr2
                         GHC.IO.Handle.FD.stdout
                         (GHC.CString.unpackAppendCString#
                            "Hi: "#
                            (GHC.Show.show @ a $dShow s))
                         GHC.Types.True
                         s1 of ds1 { (#,#) ipv ipv1 ->
                  (# ipv,
                     (GHC.Show.show @ a $dShow s, GHC.Num.+ @ a $dNum s lvl) #) })
                   `cast`
                 (Trans
                      (<a>_R ->_R Sym (GHC.Types.N:IO[0] <(GHC.Base.String, a)>_R))
                      (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <a>_N <GHC.Types.IO>_R <GHC.Base.String>_N)))) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

